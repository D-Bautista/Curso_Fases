[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Notas del Curso de Fases Topológicas del PCF 2014",
    "section": "",
    "text": "1 Índice",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Índice</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "2  Introduction",
    "section": "",
    "text": "En este libro se expondrán las notas asociadas al curso de Fases Geométricas impartido en el Posgrado de Ciencias Físicas de la UNAM por el Dr. Alberto Martín, el Dr. Eduardo Barrios y el Dr. Luis Urrutia.\nAquí se muestran las notas relacionadas a la parte de programación.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "3  Resumen",
    "section": "",
    "text": "Los temas vistos son\n\nEscribiendo un Hamiltoniano de amarre fuerte en Python\n\nsub-item 1\nsub-item 2\n\nsub-sub-item 1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Resumen</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "clase1.html",
    "href": "clase1.html",
    "title": "4  Un breve repaso de Python",
    "section": "",
    "text": "En Python podemos definir varios tipos de número. Podemos, por ejemplo, escribi un número entero.\n\n# Un número entero\n4\n\n4\n\n\nTambién podemos definir números reales. Esto se puede hacer en forma decimal o en fracción.\n\n# Un número real decimal\n1.2\n\n1.2\n\n\n\n# Un número real como fracción\n1/5\n\n0.2\n\n\nAl escribir la fracción notamos que el resultado es un número real. Sin embargo, sabemos que es posible definir la divisón de modo que el resultado sea entero. Esto se logra como sigue:\n\n# División para números enteros\n2 // 3\n\n0\n\n\nEn python se pueden hacer todas las operaciones entre números.\n\n# Resta\n1 - 2\n\n-1\n\n\n\n#Producto\n1 * 2\n\n2\n\n\nLas funciones en Python se evaluan usando paréntesis. Por ejemplo, debajo se muestra la función que hace del resultado de una operación un entero.\n\n# Ejemplo de uso de la función int\nint(3 + 1/2)\n\n3\n\n\nTambién podemos definir números complejos. Estos se logran escribiendo algo de la forma \\(a + bJ\\). Debajo se muestra un ejemplo. Cabe resaltar es importante no dejar ni un espacio entre el número y J.\n\n# Número Complejo \n1 + 2J\n\n(1+2j)\n\n\nCualquiera de estos números puede almacenarse en una variable. Por ejemplo,\n\n# Almacenando un número en una variable \nvariable = 1 + 2J\n\nPodemos aplicar una función directamente sobre una variable. Antes de ejemplificar esto, cargaremos las librerías que nos permiten hacer operaciones más complejas e introducir objetos matemáticos como vectores o matrices. Las librerías se importan debajo\n\n# Se cargan las librerías que hacen python numérico\nfrom pylab import *\n\nPor ejemplo, aplicamos la función de conjugar:\n\n# Operación conjugación \nconj(variable)\n\n(1-2j)\n\n\nUn vector se define a través de entradas ordenadas. Por ejemplo, el vector \\((1,0,0)^{\\text{T}}\\) se define como sigue\n\n# Definición de vector\narray([1,0,0])\n\narray([1, 0, 0])\n\n\nEs importante usar la función array. De lo contrario, es imposible aplicar las operaciones conocidas sobre vectores.\nOJO: Por defecto los vectores en Python son vectores renglón. También podemos guardar los vectores en variables.\n\n# Almacenando dos vectores en variables\nv = array([1,2,3])\nw = array([4,5,6])\n\nGracias a que usé array a la hora de definir estos objetos, puedo sumarlos y restarlos como vectores:\n\n# Suma de vectores\nv + w\n\narray([5, 7, 9])\n\n\n\n# Resta de vectores\nv - w\n\narray([-3, -3, -3])\n\n\nNotemos que el resultado también es un array. En general, podemos comprobar que tipo de variable es un objeto usando la función type. En este caso,\n\n# Ejemplo de función type \ntype( v )\n\nnumpy.ndarray\n\n\n\n# Ejemplo de función type \ntype(variable)\n\ncomplex\n\n\nOtra operación importante es el producto punto. Esto se hace con la función dot().\n\n# Ejemplo de proucto punto\ndot( v,w )\n\n32\n\n\nEn mecánica cuántica, sin embargo, no se usa el producto cartesiano usual. Se suele hacer el producto de un bra y un ket. Esto se hace con la función vdot. En el caso de vectores reales, dot y vdot son equivalentes.\n\n# Ejemplo de vdot\nvdot( v, w )\n\n32\n\n\nTambién, podemos extrar la entrada de una posición del vector. Pero hay que tener en cuenta que Python empieza a enumerar en cero.\n\n# Extraemos la primera entrada\nv[0]\n\n1\n\n\n\n# Extraemos la segunda entrada\nv[1]\n\n2\n\n\nPara definir una matriz, se usan corchetes dentro de corchetes. Cada corchete dentro del corchete representa un renglón. Por ejemplo, para constuir la matriz \\[\\begin{pmatrix} 1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\\end{pmatrix},\\] usamos\n\n# Definir una matriz con array\nA = array([[1,2,3],[4,5,6],[7,8,9]])\n\nTambién se puede usar la función matrix.\n\n# Definir una matriz con array\nB = matrix([[1,2,3],[4,5,6],[7,8,9]])\n\nPara obtener la transpuesta de una matriz \\(M\\) usamos \\(M.T\\). Esto sirve para ambas formas de definir una matriz .\n\n# Definir una matriz con array\nA.T\n\narray([[1, 4, 7],\n       [2, 5, 8],\n       [3, 6, 9]])\n\n\n\n# Definir una matriz con array\nB.T\n\nmatrix([[1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]])\n\n\nPodemos transponer y conjugar también. En el caso de la definición de array, debemos hacer lo siguiente\n\n# Transponer y conjugar un array\nconj( A.T )\n\narray([[1, 4, 7],\n       [2, 5, 8],\n       [3, 6, 9]])\n\n\nPara el objeto matrix, se puede usar \\(M.H\\). Esto se muestra debajo,\n\n# Operador daga en una matriz\nB.H\n\nmatrix([[1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]])\n\n\nPodemos obtener el primer renglón de una matriz de la misma forma que se extraía el primer elemento de un vector. Esto funciona tanto para la definición array como la definición matrix.\n\n# Obtener un renglón de un array\nA[0]\n\narray([1, 2, 3])\n\n\n\n# Obtener un renglón de una matriz\nB[0]\n\nmatrix([[1, 2, 3]])\n\n\nHay una sutil diferencia en el tipo de objeto de salida. En el primer caso la salida es un vector, en el segundo la salida es una matriz hecha por un sólo renglón. Aparte de type, puedo usar la función shape para saber que tengo.\n\n# Uso de función shape\nshape(A[0])\n\n(3,)\n\n\n\n# Uso de función shape\nshape(B[0])\n\n(1, 3)\n\n\nTambién, podemos extraer la primera columna. En el caso de la definición array, esto se hace como sigue:\n\n# Uso de función shape\nA.T[0]\n\narray([1, 4, 7])\n\n\nPara la definición matrix, se usa lo mismo.\n\n# Uso de función shape\nB.T[0]\n\nmatrix([[1, 4, 7]])\n\n\nDe forma alternativa, podría usar lo siguiente para el caso de matrix:\n\n# Uso de función shape\nB[:,0]\n\nmatrix([[1],\n        [4],\n        [7]])\n\n\nNotemos que esta salida si se asemeja a un vector columna.\nTambién podemos definir funciones usando def nombredefunción(variables). Al final, se añaden dos puntos. Por ejemplo,\n\n# Definiendo una función\ndef nombre(x):\n    # Dentro de una función pueden dejarse comentarios.\n    # Es usual dejar instrucciones de cálculo.\n    v = array([x,x,x])\n    return 2 * v\n\nLa función se aplica como cualquier otra.\n\n# Usando la función\nnombre(2)\n\narray([4, 4, 4])\n\n\n\n# Usando la función en otro objeto posible\nnombre( array([4,6]) )\n\narray([[ 8, 12],\n       [ 8, 12],\n       [ 8, 12]])\n\n\nSiempre es mejor pensar en funciones que reciben argumentos a la hora de tratar problemas.\nFinalmente, veamos ciclos de instrucciones. El primero es el ciclo for. Este ciclo recorre una colección de datos:\n\n# Ejempo ciclo for\ncolección = array([6,7,8])\n\nfor v in colección:\n    print(v)\n\n6\n7\n8\n\n\nEl último for puede reducirse a una sola linea.\n\n# for en una linea\n[print(v) for v in colección]\n\n6\n7\n8\n\n\n[None, None, None]\n\n\nLa colección puede ser una matriz.\n\n# for en una linea\nfor v in A:\n    print(v)\n\n[1 2 3]\n[4 5 6]\n[7 8 9]\n\n\nTambién puedo sacar los eigenvalores de una matriz. Si mi matriz es una matriz cualquiera, uso eigvals. Si mi matriz es hermítica, puedo usar eigvalsh.\n\n# Eigvals regresa los eigenvalores de una matriz sin ordenar. \neigvals(A)\n\narray([ 1.61168440e+01, -1.11684397e+00, -8.58274334e-16])",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Un breve repaso de Python</span>"
    ]
  },
  {
    "objectID": "clase2.html",
    "href": "clase2.html",
    "title": "5  Hamiltinianos de amarre fuerte en Python",
    "section": "",
    "text": "5.1 Descripción de un sistema de tres átomos\nDe esta forma, para un sistema de tres átomos que forman una cadena finita, por ejemplo, el estado de vacío es \\[| \\Omega \\rangle = | 0,0,0\\rangle\\] de modo que el operador \\(\\hat{c}^{\\dagger}_{1}\\) es tal que \\[ \\hat{c}^{\\dagger}_{0} |\\Omega \\rangle = |1,0,0\\rangle := |0 \\rangle,\\] \\[ \\hat{c}^{\\dagger}_{1} |\\Omega \\rangle = |0,1,0\\rangle := |1 \\rangle,\\] \\[ \\hat{c}^{\\dagger}_{2} |\\Omega \\rangle = |0,0,1\\rangle := |2 \\rangle.\\] Con esta notación, podemos escribir los términos asociados a energías de sitio como \\[\\hat{c}^{\\dagger}_{i} \\hat{c}_{i} = |i\\rangle \\langle i |,\\] y los términos asociados a hoppings como \\[\\hat{c}^{\\dagger}_{i} \\hat{c}_{j} = |i\\rangle \\langle j |.\\] Dicho eso, el Hamiltoniano de amarre fuerte se escribe \\[\\hat{H} = t \\hat{c}^{\\dagger}_{1} \\hat{c}_{0} + \\text{h.c.} + t \\hat{c}^{\\dagger}_{2} \\hat{c}_{1} + \\text{h.c.} = t \\hat{c}^{\\dagger}_{1} \\hat{c}_{0} + t \\hat{c}^{\\dagger}_{2} \\hat{c}_{1} + \\text{h.c.}.\\]\nAhora llevemos esto a Python, primero importamos las librerías.\nfrom pylab import *\nPodemos representar los distintos kets como vectores. Por ejemplo, para representar \\(|0 \\rangle = |1,0,0\\rangle\\) usamos la siguiente celda.\nket_cero = np.matrix([[1],[0],[0]])\nprint(ket_cero)\n\n[[1]\n [0]\n [0]]\nHacemos lo mismo para representar \\(|1 \\rangle = |0,1,0\\rangle\\), pero ahora hay que escribir un vector renglón.\nbra_uno = np.matrix([[0,1,0]])\nprint(bra_uno)\n\n[[0 1 0]]\nYa una vez definidos los estados, creamos el operador con el producto \\(|0\\rangle \\langle 1 |\\). Esto se hace con el producto de matrices. Para objetos del tipo matrix, esto se consigue con el símbolo *:\nket_cero * bra_uno\n\nmatrix([[0, 1, 0],\n        [0, 0, 0],\n        [0, 0, 0]])\nPodemos constuir el conjugado. Para ello definimos los conjugados de los bras y kets definidos y hacemos el producto matricial entre ellos. Vemos que en efecto el resultado es la matriz hermítica a la obtenida previamente.\nket_uno = np.matrix([[0],[1],[0]])\nbra_cero = np.matrix([[1,0,0]])\n\nket_uno * bra_cero\n\nmatrix([[0, 0, 0],\n        [1, 0, 0],\n        [0, 0, 0]])\nTerminamos de definir el resto de los estados.\nket_dos = np.matrix([[0],[0],[1]])\nbra_uno = np.matrix([[0,1,0]])\n\nket_dos * bra_uno\n\nmatrix([[0, 0, 0],\n        [0, 0, 0],\n        [0, 1, 0]])\nket_uno = np.matrix([[0],[1],[0]])\nbra_dos = np.matrix([[0,0,1]])\n\nket_uno * bra_dos\n\nmatrix([[0, 0, 0],\n        [0, 0, 1],\n        [0, 0, 0]])\nYa con todos los estaods definidos, podemos construir nuestro hamiltoniano de amarre fuerte. \\[\\hat{H} = t |0 \\rangle \\langle 1| + t^{*}|1 \\rangle \\langle 0| + t|1 \\rangle \\langle 2| + t^{*}|2 \\rangle \\langle 1|\\] Se definirán todos los estados de nuevo por completez, pero esto no es necesario.\nket_cero = np.matrix([[1],[0],[0]])\nket_uno  = np.matrix([[0],[1],[0]])\nket_dos  = np.matrix([[0],[0],[1]])\nbra_cero = np.matrix([[1,0,0]])\nbra_uno  = np.matrix([[0,1,0]])\nbra_dos  = np.matrix([[0,0,1]])\n\n#definimos el hopping\n\nt = 1.0\ntc = conj(t)\n\nH = t*ket_cero*bra_uno + tc*ket_uno*bra_cero \\\n  + t*ket_dos*bra_uno + tc*ket_uno*bra_dos\n\nprint(H)\n\n[[0. 1. 0.]\n [1. 0. 1.]\n [0. 1. 0.]]\nDe este operador, podemos sacar los eigenvalores y eigenvectores.\nE,U = eigh(H)\nLos eigenvalores se almacenan en E, los eigenvectores en U:\nprint(E)\n\n[-1.41421356e+00 -2.14901599e-17  1.41421356e+00]\nprint(U)\n\n[[-5.00000000e-01  7.07106781e-01  5.00000000e-01]\n [ 7.07106781e-01 -7.62399522e-17  7.07106781e-01]\n [-5.00000000e-01 -7.07106781e-01  5.00000000e-01]]\nNotamos que en U están los eigenvectores como columnas. Para ver eso, hacemos el producto de H con la primer columna y dividimos por el eigenvalor. El resultado es el vector original:\nv = np.matrix([[-5.00000000e-01],[7.07106781e-01],[-5.00000000e-01]])\n\nprint(H*v/-1.41421356e+00)\n\n[[-0.5       ]\n [ 0.70710678]\n [-0.5       ]]\nExtraemos un eigenvalor y su eigenvalor asociado. Para ello, hay que tener cuidado de trasponer la matriz antes de extraer el vector.\nE0 = E[0]\nv0 = (U.T[0]).T\nprint(v0)\n\n[[-0.5       ]\n [ 0.70710678]\n [-0.5       ]]\nPara detalles técnicos, hacemos lo mismo pero usando array en vez de matrix.\nket_uno  = np.array([[0],[1],[0]])\nbra_cero = np.array([[1,0,0]]) \n\nprint(ket_uno)\nprint(bra_cero)\n\n[[0]\n [1]\n [0]]\n[[1 0 0]]\nHasta ahora todo se ve igual. Lo mismo pasa al hacer el producto.\nket_cero = np.array([[1],[0],[0]])\nket_uno  = np.array([[0],[1],[0]])\nket_dos  = np.array([[0],[0],[1]])\nbra_cero = np.array([[1,0,0]]) \nbra_uno  = np.array([[0,1,0]])\nbra_dos  = np.array([[0,0,1]])\n\nt = 1.0\ntc = conj(t)\n\nH = t*ket_cero*bra_uno + tc*ket_uno*bra_cero \\\n  + t*ket_dos*bra_uno + tc*ket_uno*bra_dos\n\nprint(H)\n\n[[0. 1. 0.]\n [1. 0. 1.]\n [0. 1. 0.]]\nLos eigenvectores y eigenvalores se sacan de la misma forma.\nE,U = eigh(H)\nprint(E)\nprint(U)\n\n[-1.41421356e+00 -2.14901599e-17  1.41421356e+00]\n[[-5.00000000e-01  7.07106781e-01  5.00000000e-01]\n [ 7.07106781e-01 -7.62399522e-17  7.07106781e-01]\n [-5.00000000e-01 -7.07106781e-01  5.00000000e-01]]\nEn conclusión: Usar array o matrix da la misma descripción para nuestros fines.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Hamiltinianos de amarre fuerte en Python</span>"
    ]
  },
  {
    "objectID": "clase2.html#descripción-de-un-triángulo",
    "href": "clase2.html#descripción-de-un-triángulo",
    "title": "5  Hamiltinianos de amarre fuerte en Python",
    "section": "5.2 Descripción de un triángulo",
    "text": "5.2 Descripción de un triángulo\nAhora supongamos que los átomos se ordenan en un triángulo. Esto implica que al Hamiltoniano se le añade una interacción entre el sitio \\(|0\\rangle\\) y el \\(|2\\rangle\\). En este caso, el hamiltoniano de amarre fuerte es \\[\\hat{H} = t \\hat{c}^{\\dagger}_{1} \\hat{c}_{0} + t \\hat{c}^{\\dagger}_{2} \\hat{c}_{1} + t \\hat{c}^{\\dagger}_{0} \\hat{c}_{2} + \\text{h.c.}.\\]\nEscribimos este hamiltoniano en código.\n\nket_cero = np.array([[1],[0],[0]])\nket_uno  = np.array([[0],[1],[0]])\nket_dos  = np.array([[0],[0],[1]])\nbra_cero = np.array([[1,0,0]]) \nbra_uno  = np.array([[0,1,0]])\nbra_dos  = np.array([[0,0,1]])\n\nt = 1.0\ntc = conj(t)\n\nH = t*ket_cero*bra_uno + tc*ket_uno*bra_cero \\\n  + t*ket_uno*bra_dos + tc*ket_dos*bra_uno   \\\n  + t*ket_cero*bra_dos + tc*ket_dos*bra_cero\n\nprint(H)\n\n[[0. 1. 1.]\n [1. 0. 1.]\n [1. 1. 0.]]\n\n\nPara este caso, hay una degeneración de los eigenvalores.\n\neigvalsh(H)\n\narray([-1., -1.,  2.])\n\n\n¿A qué se debe la simetría? A que en este caso el sistema tiene una simetría \\(C_{3}\\). El operador asociado a esa simetría en la base de orbitales localizados se ve como una permutación. \\[R = \\begin{pmatrix} 0 & 0 & 1 \\\\\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\end{pmatrix}.\\] Corroboramos que esta matriz conmuta con el hamiltoniano. Para ello, definimos la matriz debajo\n\nR = np.matrix([[0,0,1],[1,0,0],[0,1,0]])\nprint(R)\n\n[[0 0 1]\n [1 0 0]\n [0 1 0]]\n\n\nLuego, aplicamos el conmutador\n\nprint(H * R - R * H)\n\n[[0. 0. 0.]\n [0. 0. 0.]\n [0. 0. 0.]]\n\n\nNOTA: Para calcular el conmutador se usó el objeto matrix. Esto se debe a que a la hora de calcular productos de matrices de misma dimensión, la operación “” se convierte en un producto entrada a entrada para objetos tipo array. Para objetos tipo matrix, ”” siempre denota producto matricial.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Hamiltinianos de amarre fuerte en Python</span>"
    ]
  },
  {
    "objectID": "clase2.html#hamiltoniano-de-amarre-fuerte-de-un-cristal",
    "href": "clase2.html#hamiltoniano-de-amarre-fuerte-de-un-cristal",
    "title": "5  IHamiltinianos de amarre fuerte en Python",
    "section": "5.3 Hamiltoniano de amarre fuerte de un cristal",
    "text": "5.3 Hamiltoniano de amarre fuerte de un cristal",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>IHamiltinianos de amarre fuerte en Python</span>"
    ]
  },
  {
    "objectID": "clase3.html",
    "href": "clase3.html",
    "title": "6  Introducción a Python Tight-Binding",
    "section": "",
    "text": "6.1 Hamiltoniano de amarre fuerte de un cristal cuadrado con campo magnético\nBuscamos describir una red cuadrada sobre la que actúa un campo magnético. Una red se define mediante dos vectores base \\(\\vec{a}_{1},\\vec{a}_{2}\\). Explítamente, una red es igual al conjunto de puntos de la forma \\[\\vec{R} = n_{1} \\vec{a}_{1} + n_{2}\\vec{a}_{2},\\] donde \\(n_{i} \\in \\mathbb{Z}\\). Imaginamos que sobre cada punto de la red hay un orbital. A cada enlace entre dos órbitales le asociamos un hopping \\(t\\). Usualmente, sólo damos hoppings no nulos a los vecinos cercanos.\nPythTB nos permite implementar cada uno de estos ingredientes en un código.\nfrom pylab import *\nfrom pythtb import *\nPrimero, definimos los vectores base y los guardamos dentro de la variable vectoresRed. Posteriormente, definimos el sitio de los orbitales de nuestra red. La posición de los orbitales debe ser una combinación lineal de los vectores base. En este caso, para poner el orbital sobre los puntos de red la posición del orbital debe ser \\(\\vec{S} = 0 \\cdot\\vec{a}_{1} + 0\\cdot\\vec{a}_{2}\\). Guardamos la posición del orbital en la variable sitio. Usualmente, habrá más de un órbital. Luego de definir la posición de todos los orbitales, debemos guardar sus posiciones en un nuevo array. En este modelo, sólo hay un orbital, pero lo guardamos en una lista llamada orbitales aparte para prepararnos al caso en que haya más orbitales.\nYa con esto listo podemos definir un objeto tb_model. La entrada a este modelo son la dimensión del espacio k, la dimensión del espacio r, los vectores de red y la lista con la posición de los orbitales. Ya hecho el modelo, podemos añadir hoppings. Para ello se usa el método set_hop. Este método recibe el valor del hopping, el índice del primer orbital del enalce (en este caso sólo hay un orbital cuyo índice es \\(i = 0\\)), el índice del segundo orbital en el enlace y el vector de red que apunta a la celda del segundo orbital.\nPara ver que los hoppings se hayan puesto bien usamos el método visualize sobre nuestro modelo. La entrada de este método es sobre que vectores base se hará la visualización. En este caso sólo hay dos vectores y por ello ponemos \\((0,1)\\).\nNotamos que por default pythtb añade los hoppings conjugados.\na1  = array([1,0])\na2  = array([0,1])\n\nvectoresRed = array([a1,a2]) #0*a1 + 0*a2\n\nsitio = array([0,0]) #Sitio del orbital\n\norbitales = array([sitio]) #Lista con todos los itios. \n\n# Definimos el Hamiltoniano de amarre fuerte.\ncuadrada = tb_model(2,2, vectoresRed, orbitales)\n\n#Definimos los hoppings.\nt = 0\ncuadrada.set_hop(t,0,0,[1,0])\n# Enlace entre orbital 0 y orbital 0 desplazo por 1*a1 + 0*a2\ncuadrada.set_hop(t,0,0,[0,1])\n# Enlace entre orbital 0 y orbital 0 desplazo por 0*a1 + 1*a2\n\ncuadrada.visualize(0,1)\n# (0,1) significa en la dirección de a1 y a2.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Introducción a Python Tight-Binding</span>"
    ]
  }
]