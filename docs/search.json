[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Notas del Curso de Fases Topológicas del PCF 2014",
    "section": "",
    "text": "1 Índice",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Índice</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "2  Introduction",
    "section": "",
    "text": "En este libro se expondrán las notas asociadas al curso de Fases Geométricas impartido en el Posgrado de Ciencias Físicas de la UNAM por el Dr. Alberto Martín, el Dr. Eduardo Barrios y el Dr. Luis Urrutia.\nAquí se muestran las notas relacionadas a la parte de programación.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "3  Resumen",
    "section": "",
    "text": "Los temas vistos son\n\nEscribiendo un Hamiltoniano de amarre fuerte en Python\n\nsub-item 1\nsub-item 2\n\nsub-sub-item 1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Resumen</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "clase1.html",
    "href": "clase1.html",
    "title": "4  Un breve repaso de Python",
    "section": "",
    "text": "En Python podemos definir varios tipos de número. Podemos, por ejemplo, escribi un número entero.\n\n# Un número entero\n4\n\n4\n\n\nTambién podemos definir números reales. Esto se puede hacer en forma decimal o en fracción.\n\n# Un número real decimal\n1.2\n\n1.2\n\n\n\n# Un número real como fracción\n1/5\n\n0.2\n\n\nAl escribir la fracción notamos que el resultado es un número real. Sin embargo, sabemos que es posible definir la divisón de modo que el resultado sea entero. Esto se logra como sigue:\n\n# División para números enteros\n2 // 3\n\n0\n\n\nEn python se pueden hacer todas las operaciones entre números.\n\n# Resta\n1 - 2\n\n-1\n\n\n\n#Producto\n1 * 2\n\n2\n\n\nLas funciones en Python se evaluan usando paréntesis. Por ejemplo, debajo se muestra la función que hace del resultado de una operación un entero.\n\n# Ejemplo de uso de la función int\nint(3 + 1/2)\n\n3\n\n\nTambién podemos definir números complejos. Estos se logran escribiendo algo de la forma \\(a + bJ\\). Debajo se muestra un ejemplo. Cabe resaltar es importante no dejar ni un espacio entre el número y J.\n\n# Número Complejo \n1 + 2J\n\n(1+2j)\n\n\nCualquiera de estos números puede almacenarse en una variable. Por ejemplo,\n\n# Almacenando un número en una variable \nvariable = 1 + 2J\n\nPodemos aplicar una función directamente sobre una variable. Antes de ejemplificar esto, cargaremos las librerías que nos permiten hacer operaciones más complejas e introducir objetos matemáticos como vectores o matrices. Las librerías se importan debajo\n\n# Se cargan las librerías que hacen python numérico\nfrom pylab import *\n\nPor ejemplo, aplicamos la función de conjugar:\n\n# Operación conjugación \nconj(variable)\n\n(1-2j)\n\n\nUn vector se define a través de entradas ordenadas. Por ejemplo, el vector \\((1,0,0)^{\\text{T}}\\) se define como sigue\n\n# Definición de vector\narray([1,0,0])\n\narray([1, 0, 0])\n\n\nEs importante usar la función array. De lo contrario, es imposible aplicar las operaciones conocidas sobre vectores.\nOJO: Por defecto los vectores en Python son vectores renglón. También podemos guardar los vectores en variables.\n\n# Almacenando dos vectores en variables\nv = array([1,2,3])\nw = array([4,5,6])\n\nGracias a que usé array a la hora de definir estos objetos, puedo sumarlos y restarlos como vectores:\n\n# Suma de vectores\nv + w\n\narray([5, 7, 9])\n\n\n\n# Resta de vectores\nv - w\n\narray([-3, -3, -3])\n\n\nNotemos que el resultado también es un array. En general, podemos comprobar que tipo de variable es un objeto usando la función type. En este caso,\n\n# Ejemplo de función type \ntype( v )\n\nnumpy.ndarray\n\n\n\n# Ejemplo de función type \ntype(variable)\n\ncomplex\n\n\nOtra operación importante es el producto punto. Esto se hace con la función dot().\n\n# Ejemplo de proucto punto\ndot( v,w )\n\n32\n\n\nEn mecánica cuántica, sin embargo, no se usa el producto cartesiano usual. Se suele hacer el producto de un bra y un ket. Esto se hace con la función vdot. En el caso de vectores reales, dot y vdot son equivalentes.\n\n# Ejemplo de vdot\nvdot( v, w )\n\n32\n\n\nTambién, podemos extrar la entrada de una posición del vector. Pero hay que tener en cuenta que Python empieza a enumerar en cero.\n\n# Extraemos la primera entrada\nv[0]\n\n1\n\n\n\n# Extraemos la segunda entrada\nv[1]\n\n2\n\n\nPara definir una matriz, se usan corchetes dentro de corchetes. Cada corchete dentro del corchete representa un renglón. Por ejemplo, para constuir la matriz \\[\\begin{pmatrix} 1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\\end{pmatrix},\\] usamos\n\n# Definir una matriz con array\nA = array([[1,2,3],[4,5,6],[7,8,9]])\n\nTambién se puede usar la función matrix.\n\n# Definir una matriz con array\nB = matrix([[1,2,3],[4,5,6],[7,8,9]])\n\nPara obtener la transpuesta de una matriz \\(M\\) usamos \\(M.T\\). Esto sirve para ambas formas de definir una matriz .\n\n# Definir una matriz con array\nA.T\n\narray([[1, 4, 7],\n       [2, 5, 8],\n       [3, 6, 9]])\n\n\n\n# Definir una matriz con array\nB.T\n\nmatrix([[1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]])\n\n\nPodemos transponer y conjugar también. En el caso de la definición de array, debemos hacer lo siguiente\n\n# Transponer y conjugar un array\nconj( A.T )\n\narray([[1, 4, 7],\n       [2, 5, 8],\n       [3, 6, 9]])\n\n\nPara el objeto matrix, se puede usar \\(M.H\\). Esto se muestra debajo,\n\n# Operador daga en una matriz\nB.H\n\nmatrix([[1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]])\n\n\nPodemos obtener el primer renglón de una matriz de la misma forma que se extraía el primer elemento de un vector. Esto funciona tanto para la definición array como la definición matrix.\n\n# Obtener un renglón de un array\nA[0]\n\narray([1, 2, 3])\n\n\n\n# Obtener un renglón de una matriz\nB[0]\n\nmatrix([[1, 2, 3]])\n\n\nHay una sutil diferencia en el tipo de objeto de salida. En el primer caso la salida es un vector, en el segundo la salida es una matriz hecha por un sólo renglón. Aparte de type, puedo usar la función shape para saber que tengo.\n\n# Uso de función shape\nshape(A[0])\n\n(3,)\n\n\n\n# Uso de función shape\nshape(B[0])\n\n(1, 3)\n\n\nTambién, podemos extraer la primera columna. En el caso de la definición array, esto se hace como sigue:\n\n# Uso de función shape\nA.T[0]\n\narray([1, 4, 7])\n\n\nPara la definición matrix, se usa lo mismo.\n\n# Uso de función shape\nB.T[0]\n\nmatrix([[1, 4, 7]])\n\n\nDe forma alternativa, podría usar lo siguiente para el caso de matrix:\n\n# Uso de función shape\nB[:,0]\n\nmatrix([[1],\n        [4],\n        [7]])\n\n\nNotemos que esta salida si se asemeja a un vector columna.\nTambién podemos definir funciones usando def nombredefunción(variables). Al final, se añaden dos puntos. Por ejemplo,\n\n# Definiendo una función\ndef nombre(x):\n    # Dentro de una función pueden dejarse comentarios.\n    # Es usual dejar instrucciones de cálculo.\n    v = array([x,x,x])\n    return 2 * v\n\nLa función se aplica como cualquier otra.\n\n# Usando la función\nnombre(2)\n\narray([4, 4, 4])\n\n\n\n# Usando la función en otro objeto posible\nnombre( array([4,6]) )\n\narray([[ 8, 12],\n       [ 8, 12],\n       [ 8, 12]])\n\n\nSiempre es mejor pensar en funciones que reciben argumentos a la hora de tratar problemas.\nFinalmente, veamos ciclos de instrucciones. El primero es el ciclo for. Este ciclo recorre una colección de datos:\n\n# Ejempo ciclo for\ncolección = array([6,7,8])\n\nfor v in colección:\n    print(v)\n\n6\n7\n8\n\n\nEl último for puede reducirse a una sola linea.\n\n# for en una linea\n[print(v) for v in colección]\n\n6\n7\n8\n\n\n[None, None, None]\n\n\nLa colección puede ser una matriz.\n\n# for en una linea\nfor v in A:\n    print(v)\n\n[1 2 3]\n[4 5 6]\n[7 8 9]\n\n\nTambién puedo sacar los eigenvalores de una matriz. Si mi matriz es una matriz cualquiera, uso eigvals. Si mi matriz es hermítica, puedo usar eigvalsh.\n\n# Eigvals regresa los eigenvalores de una matriz sin ordenar. \neigvals(A)\n\narray([ 1.61168440e+01, -1.11684397e+00, -8.58274334e-16])",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Un breve repaso de Python</span>"
    ]
  },
  {
    "objectID": "clase2.html",
    "href": "clase2.html",
    "title": "5  Introducción a PythonTB",
    "section": "",
    "text": "Ahora empezaremos a usar PythonTB.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introducción a PythonTB</span>"
    ]
  }
]